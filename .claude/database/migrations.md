# 마이그레이션 및 시드 데이터 문서

## 마이그레이션 현황

BuckPal 프로젝트는 **마이그레이션 도구를 사용하지 않고** Hibernate의 **DDL Auto 기능**에 의존합니다.

### 현재 마이그레이션 전략
- **도구**: 없음 (Flyway, Liquibase 미사용)
- **스키마 생성**: Hibernate `ddl-auto: create-drop`
- **버전 관리**: 없음
- **롤백 전략**: 없음

## 스키마 생성 방식

### 1. DDL Auto 설정

**파일**: `src/main/resources/application-local.yml`

```yaml
spring:
  jpa:
    hibernate:
      ddl-auto: create-drop  # 애플리케이션 시작 시 스키마 재생성
    properties:
      hibernate:
        show_sql: false      # SQL 콘솔 출력 비활성화
        format_sql: true     # SQL 포맷팅 활성화
        use_sql_comments: true # SQL 주석 추가
```

### 2. 실제 생성되는 DDL

Hibernate가 자동 생성하는 테이블 구조:

```sql
-- Account 테이블
CREATE TABLE account (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    PRIMARY KEY (id)
);

-- Activity 테이블  
CREATE TABLE activity (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    amount BIGINT,
    owner_account_id BIGINT,
    source_account_id BIGINT,
    target_account_id BIGINT,
    timestamp TIMESTAMP,
    PRIMARY KEY (id)
);
```

#### 특징
- ✅ **자동 생성**: JPA 어노테이션 기반 스키마 생성
- ❌ **제약조건 부족**: 외래키, NOT NULL, CHECK 제약조건 없음
- ❌ **인덱스 없음**: 성능 최적화 인덱스 부재
- ⚠️ **데이터 손실**: `create-drop`으로 재시작 시 데이터 초기화

## 테스트 시드 데이터

### 1. 시스템 테스트용 데이터

**파일**: `src/test/resources/dev/haja/buckpal/SendMoneySystemTest.sql`

```sql
-- 테스트 계좌 생성
INSERT INTO account (id) VALUES (1);
INSERT INTO account (id) VALUES (2);

-- 송금 거래 시나리오 (이중 기록 방식)
-- 2018년 8월 8일: 계좌1 → 계좌2 (500원)
INSERT INTO activity (id, timestamp, owner_account_id, source_account_id, target_account_id, amount)
VALUES (1001, '2018-08-08 08:00:00.0', 1, 1, 2, 500);  -- 계좌1의 출금 기록

INSERT INTO activity (id, timestamp, owner_account_id, source_account_id, target_account_id, amount)  
VALUES (1002, '2018-08-08 08:00:00.0', 2, 1, 2, 500);  -- 계좌2의 입금 기록

-- 2018년 8월 9일: 계좌2 → 계좌1 (1000원)
INSERT INTO activity (id, timestamp, owner_account_id, source_account_id, target_account_id, amount)
VALUES (1003, '2018-08-09 10:00:00.0', 1, 2, 1, 1000); -- 계좌1의 입금 기록

INSERT INTO activity (id, timestamp, owner_account_id, source_account_id, target_account_id, amount)
VALUES (1004, '2018-08-09 10:00:00.0', 2, 2, 1, 1000); -- 계좌2의 출금 기록

-- 2019년 8월 9일: 계좌1 → 계좌2 (1000원)  
INSERT INTO activity (id, timestamp, owner_account_id, source_account_id, target_account_id, amount)
VALUES (1005, '2019-08-09 09:00:00.0', 1, 1, 2, 1000);

INSERT INTO activity (id, timestamp, owner_account_id, source_account_id, target_account_id, amount)
VALUES (1006, '2019-08-09 09:00:00.0', 2, 1, 2, 1000);

-- 2019년 8월 9일: 계좌2 → 계좌1 (1000원)
INSERT INTO activity (id, timestamp, owner_account_id, source_account_id, target_account_id, amount)
VALUES (1007, '2019-08-09 10:00:00.0', 1, 2, 1, 1000);

INSERT INTO activity (id, timestamp, owner_account_id, source_account_id, target_account_id, amount)
VALUES (1008, '2019-08-09 10:00:00.0', 2, 2, 1, 1000);
```

#### 시드 데이터 분석

**거래 시나리오 요약**:
1. **계좌1 → 계좌2**: 500원 (2018-08-08)
2. **계좌2 → 계좌1**: 1000원 (2018-08-09)  
3. **계좌1 → 계좌2**: 1000원 (2019-08-09)
4. **계좌2 → 계좌1**: 1000원 (2019-08-09)

**최종 잔액 계산**:
- **계좌1**: -500 + 1000 - 1000 + 1000 = **500원**
- **계좌2**: +500 - 1000 + 1000 - 1000 = **-500원** (음수 잔액)

### 2. 영속성 어댑터 테스트용 데이터

**파일**: `src/test/resources/dev/haja/buckpal/account/adapter/out/persistence/AccountPersistenceAdapterTest.sql`

```sql
-- 기본 계좌 설정
INSERT INTO account (id) VALUES (1);
INSERT INTO account (id) VALUES (2);

-- 더 간소한 테스트 시나리오
-- 2018년: 2번의 양방향 거래
INSERT INTO activity (id, timestamp, owner_account_id, source_account_id, target_account_id, amount)
VALUES (1, '2018-08-08 08:00:00.0', 1, 1, 2, 500),
       (2, '2018-08-08 08:00:00.0', 2, 1, 2, 500),
       (3, '2018-08-09 10:00:00.0', 1, 2, 1, 1000),
       (4, '2018-08-09 10:00:00.0', 2, 2, 1, 1000);

-- 2019년: 2번의 양방향 거래  
INSERT INTO activity (id, timestamp, owner_account_id, source_account_id, target_account_id, amount)
VALUES (5, '2019-08-09 09:00:00.0', 1, 1, 2, 1000),
       (6, '2019-08-09 09:00:00.0', 2, 1, 2, 1000),
       (7, '2019-08-09 10:00:00.0', 1, 2, 1, 1000),
       (8, '2019-08-09 10:00:00.0', 2, 2, 1, 1000);
```

#### 특징
- **단위 테스트**: 영속성 어댑터의 기본 기능 검증
- **시간 범위**: 2018년~2019년 약 1년간
- **ID 순차**: 1~8번으로 단순한 식별자

## 데이터 로딩 방식

### 1. @Sql 어노테이션 활용

```java
@Test
@DisplayName("sendMoney: 요청 생성 -> App에 보내고 응답상태와 계좌의 새로운 잔고를 검증")
@Sql("SendMoneySystemTest.sql")
void sendMoney() {
    // 테스트 로직
}
```

#### 특징
- **자동 실행**: 각 테스트 메서드 실행 전 SQL 스크립트 실행
- **격리성**: 테스트 간 데이터 격리 보장
- **편의성**: 별도 데이터 셋업 코드 불필요

### 2. 테스트용 설정

**파일**: `src/test/resources/application.yml`

```yaml  
# 테스트 환경 설정 (H2 기본값 사용)
spring:
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
```

## 프로덕션 마이그레이션 전략 (권장)

### 1. Flyway 도입 방안

#### 의존성 추가
```kotlin
// build.gradle.kts
implementation("org.flywaydb:flyway-core")
```

#### 설정 추가
```yaml
# application-prod.yml
spring:
  jpa:
    hibernate:
      ddl-auto: validate  # 스키마 검증만 수행
  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true
```

#### 마이그레이션 파일 구조
```
src/main/resources/db/migration/
├── V1__Create_base_schema.sql
├── V2__Add_constraints.sql  
├── V3__Add_indexes.sql
└── V4__Add_audit_columns.sql
```

### 2. 단계별 마이그레이션 스크립트

#### V1__Create_base_schema.sql
```sql
-- 기본 테이블 생성
CREATE TABLE account (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
);

CREATE TABLE activity (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    owner_account_id BIGINT NOT NULL,
    source_account_id BIGINT NOT NULL,
    target_account_id BIGINT NOT NULL,
    amount BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
);
```

#### V2__Add_constraints.sql  
```sql
-- 비즈니스 제약조건 추가
ALTER TABLE activity 
ADD CONSTRAINT chk_activity_amount_positive 
CHECK (amount > 0);

ALTER TABLE activity
ADD CONSTRAINT chk_activity_different_accounts
CHECK (source_account_id <> target_account_id);

ALTER TABLE activity
ADD CONSTRAINT fk_activity_owner
FOREIGN KEY (owner_account_id) REFERENCES account(id);

ALTER TABLE activity
ADD CONSTRAINT fk_activity_source  
FOREIGN KEY (source_account_id) REFERENCES account(id);

ALTER TABLE activity
ADD CONSTRAINT fk_activity_target
FOREIGN KEY (target_account_id) REFERENCES account(id);
```

#### V3__Add_indexes.sql
```sql  
-- 성능 최적화 인덱스
CREATE INDEX idx_activity_owner_timestamp 
ON activity (owner_account_id, timestamp);

CREATE INDEX idx_activity_source_timestamp
ON activity (source_account_id, timestamp);

CREATE INDEX idx_activity_target_timestamp  
ON activity (target_account_id, timestamp);

CREATE INDEX idx_activity_timestamp
ON activity (timestamp);
```

### 3. 시드 데이터 관리

#### R__Insert_master_data.sql (Repeatable)
```sql
-- 마스터 데이터 (매번 실행)
DELETE FROM account WHERE id IN (1, 2);

INSERT INTO account (id) VALUES (1), (2);
```

## 롤백 전략

### 1. 현재 상황
- ❌ **롤백 불가능**: DDL Auto 방식으로 롤백 메커니즘 없음
- ⚠️ **데이터 손실 위험**: create-drop으로 데이터 완전 초기화
- ❌ **버전 추적 없음**: 스키마 변경 이력 없음

### 2. Flyway 도입 시 롤백 전략

#### 전진 전용 (Forward-only) 마이그레이션
```sql
-- V5__Remove_deprecated_column.sql
-- 컬럼 제거 대신 비활성화
ALTER TABLE activity ADD COLUMN deprecated_field_active BOOLEAN DEFAULT FALSE;

-- V6__Migrate_deprecated_data.sql  
-- 데이터 마이그레이션 후 컬럼 무시
UPDATE activity SET deprecated_field_active = FALSE WHERE deprecated_field IS NOT NULL;
```

#### 응급 핫픽스 전략
```sql
-- V7__Hotfix_constraint_issue.sql
-- 문제가 된 제약조건 일시 해제
ALTER TABLE activity DROP CONSTRAINT IF EXISTS chk_activity_amount_positive;

-- V8__Restore_fixed_constraint.sql
-- 수정된 제약조건 재적용  
ALTER TABLE activity ADD CONSTRAINT chk_activity_amount_positive 
CHECK (amount > 0);
```

## 환경별 데이터 관리

### 1. 개발 환경
- **DDL Auto**: `create-drop`
- **시드 데이터**: @Sql 어노테이션
- **리셋 주기**: 애플리케이션 재시작 시

### 2. 테스트 환경  
- **DDL Auto**: `create-drop`
- **시드 데이터**: SQL 스크립트
- **격리**: 각 테스트 메서드별 독립적 데이터

### 3. 프로덕션 환경 (권장)
- **DDL Auto**: `validate`
- **마이그레이션**: Flyway
- **시드 데이터**: Repeatable 스크립트
- **백업**: 마이그레이션 전 자동 백업

## 데이터 일관성 보장

### 1. 현재 문제점
- ❌ **참조 무결성**: 외래키 제약조건 없음
- ❌ **도메인 제약조건**: 비즈니스 규칙 미적용
- ❌ **동시성 제어**: 락 메커니즘 없음

### 2. 개선 방안
```sql
-- 트리거를 통한 일관성 보장 (H2 지원)
CREATE TRIGGER activity_consistency_check 
BEFORE INSERT ON activity
FOR EACH ROW
BEGIN
    -- 계좌 존재 여부 확인
    IF NOT EXISTS (SELECT 1 FROM account WHERE id = NEW.owner_account_id) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Owner account does not exist';
    END IF;
    
    -- 금액 양수 확인
    IF NEW.amount <= 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Amount must be positive';  
    END IF;
END;
```

**현재 마이그레이션 전략은 개발 편의성을 위한 최소한의 구성이며, 프로덕션 환경에서는 Flyway 등 전문 마이그레이션 도구 도입이 필수적입니다.**